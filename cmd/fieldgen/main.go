package main

import (
	"flag"
	"fmt"
	"go/types"
	"os"
	re "regexp"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("types", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "", "output file name; default srcdir/<type>_string.go")
)

func usage() {
	fmt.Fprintf(os.Stderr, "Usage:")
	fmt.Fprintf(os.Stderr, "\tfieldgen -types <comma separated list of type names> [-output <output file>]")
}

var tagPattern = re.MustCompile(`json:"([^"]+)"`)

const basicTypeFieldConst = `const %s string = "%s"
`

const structTypeFieldFunc = `func %s(subFieldFunc func() string, subFieldFuncs ...func() string) string {
	subFields := []string{subFieldFunc()}
	for _, f := range subFieldFuncs {
		subFields = append(subFields, f())
	}
	return "%s{\n"+strings.Join(subFields, "\n")+"}"
}
`

func main() {
	flag.Usage = usage
	flag.Parse()
	if *typeNames == "" {
		flag.Usage()
		os.Exit(2)
	}
	types := strings.Split(*typeNames, ",")

	pkg, err := loadPackage()
	if err != nil {
		panic(err)
	}
	var outputFileName string
	if *output != "" {
		outputFileName = *output
	} else if len(types) == 1 {
		outputFileName = fmt.Sprintf("%s_fields.go", types[0])
	} else {
		fmt.Fprintf(os.Stderr, "-output needs to be set if giving multiple types")
		os.Exit(2)
	}

	header := fmt.Sprintf(`//generated by eywa. DO NOT EDIT. Any changes will be overwritten.
package %s
`, pkg.Name)
	gen := ""
	for _, t := range types {
		gen += parseType(t, pkg)
	}
	if gen == "" {
		return
	}
	if err := writeToFile(outputFileName, header+gen); err != nil {
		fmt.Fprint(os.Stderr, err.Error())
		os.Exit(1)
	}
}

func parseType(typeName string, pkg *packages.Package) string {
	typeObj := pkg.Types.Scope().Lookup(typeName)
	if typeObj == nil {
		panic("type not found in package")
	}
	typeStruct, ok := typeObj.Type().Underlying().(*types.Struct)
	if !ok {
		panic("type %v is not a struct")
	}

	gen := ""
	importStrings := false
	for i := 0; i < typeStruct.NumFields(); i++ {
		tag := tagPattern.FindStringSubmatch(typeStruct.Tag(i))
		if tag == nil {
			continue
		}
		tagValue := strings.Split(tag[1], ",")
		if len(tagValue) == 0 {
			continue
		}
		fieldName := tagValue[0]
		structField := typeStruct.Field(i)
		structFieldType := structField.Type()

		if ptr, ok := structFieldType.(*types.Pointer); ok {
			structFieldType = ptr.Elem()
		}

		switch structFieldType.(type) {
		case *types.Basic, *types.Map:
			gen += fmt.Sprintf(
				basicTypeFieldConst,
				fmt.Sprintf("%s_%s", typeName, structField.Name()),
				fieldName,
			)
		case *types.Struct, *types.Slice:
			importStrings = true
			gen += fmt.Sprintf(
				structTypeFieldFunc,
				fmt.Sprintf("%s_%s", typeName, structField.Name()),
				fieldName,
			)
		default:
		}
	}
	if importStrings {
		return "import \"strings\"\n" + gen
	}
	return gen
}

func writeToFile(filename, content string) error {
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	if _, err := f.Write([]byte(content)); err != nil {
		return err
	}
	return nil
}

func loadPackage() (*packages.Package, error) {
	cfg := &packages.Config{Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo, Tests: true}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		return nil, fmt.Errorf("couldn't load package: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		return nil, fmt.Errorf("package contains errors")
	}
	return pkgs[0], nil
}
